# 问题分析：认证数据与任职数据人数不一致

## 问题描述

在全员状态下，相同职位类的认证数据（`/person-cert-details`）与任职数据（`/cadre-qualified-details`）的人数总数不一致。

## 根本原因

两个查询的去重逻辑不一致，导致认证数据查询可能为同一员工产生多条记录。

### 1. 认证数据查询（`getEmployeeCertDetailsByDeptLevel`）

**位置**：`EmployeeMapper.xml` 第114-254行

**问题点**：
- 使用 `SELECT DISTINCT`，但 SELECT 字段中包含 `cert.cer_title` 和 `cert.start_time`
- **没有使用 `GROUP BY e.employee_number`**
- 如果一个员工有多张不同的证书（不同的证书标题或开始时间），会产生多条记录

**当前SQL结构**：
```sql
SELECT DISTINCT
    e.last_name AS name,
    e.employee_number AS employeeNumber,
    ...
    cert.cer_title AS certTitle,        -- 证书标题
    cert.start_time AS certStartTime,   -- 证书开始时间
    ...
FROM t_employee_sync e
INNER JOIN ... cert ON (e.employee_number = cert.employee_number)
...
ORDER BY e.employee_number, COALESCE(cert.start_time, '1900-01-01')
-- 注意：没有 GROUP BY
```

**问题示例**：
- 员工A有2张证书：
  - 证书1：`华为研究类能力认证（专业级，AI算法技术）`，开始时间：2024-01-01
  - 证书2：`华为研究类能力认证（专业级，AI决策推理）`，开始时间：2024-02-01
- 结果：员工A会产生**2条记录**（因为 `cert.cer_title` 和 `cert.start_time` 不同）

### 2. 任职数据查询（`getEmployeeQualifiedDetailsByDeptLevel`）

**位置**：`EmployeeMapper.xml` 第311-524行

**处理方式**：
- 使用 `GROUP BY e.employee_number` 确保每个员工只有一条记录
- 对于其他字段使用 `ANY_VALUE()` 进行聚合

**当前SQL结构**：
```sql
SELECT 
    ANY_VALUE(e.last_name) AS name,
    e.employee_number AS employeeNumber,
    ...
FROM t_employee_sync e
INNER JOIN t_qualifications q ON (...)
...
GROUP BY e.employee_number  -- 关键：按员工号分组
ORDER BY e.employee_number, COALESCE(q.competence_from, '1900-01-01')
```

**结果**：每个员工只会产生**1条记录**

## 解决方案

修改认证数据查询，使用 `GROUP BY e.employee_number` 来确保每个员工只有一条记录。

### 修改方案

将 `getEmployeeCertDetailsByDeptLevel` 方法：
1. 将 `SELECT DISTINCT` 改为 `SELECT`，并使用 `ANY_VALUE()` 包装非分组字段
2. 添加 `GROUP BY e.employee_number`
3. 对于证书相关字段（`certTitle`, `certStartTime`），可以选择：
   - 方案A：使用 `ANY_VALUE()` 取任意一个证书信息
   - 方案B：使用 `MAX()` 或 `MIN()` 取最新或最早的证书信息
   - 方案C：使用 `GROUP_CONCAT()` 合并所有证书信息（需要修改返回结构）

### 推荐方案

**方案A（推荐）**：使用 `ANY_VALUE()` 取任意一个证书信息，与任职数据查询保持一致。

**修改后的SQL结构**：
```sql
SELECT 
    ANY_VALUE(e.last_name) AS name,
    e.employee_number AS employeeNumber,
    ANY_VALUE(
        CASE 
            WHEN e.job_category LIKE '%-%-%' THEN SUBSTRING_INDEX(SUBSTRING_INDEX(e.job_category, '-', 2), '-', -1)
            WHEN e.job_category LIKE '%-%' THEN SUBSTRING_INDEX(e.job_category, '-', -1)
            ELSE e.job_category
        END
    ) AS competenceCategory,
    ...
    ANY_VALUE(cert.cer_title) AS certTitle,
    ANY_VALUE(cert.start_time) AS certStartTime,
    ...
FROM t_employee_sync e
INNER JOIN ... cert ON (e.employee_number = cert.employee_number)
...
GROUP BY e.employee_number  -- 新增：按员工号分组
ORDER BY e.employee_number, COALESCE(ANY_VALUE(cert.start_time), '1900-01-01')
```

## 影响分析

### 修改后的影响

1. **数据一致性**：认证数据和任职数据的人数统计将保持一致
2. **数据准确性**：每个员工只统计一次，符合业务预期
3. **性能影响**：添加 `GROUP BY` 可能会有轻微的性能影响，但通常可以忽略

### 注意事项

1. 如果业务需要显示员工的所有证书信息，需要修改返回结构（例如使用数组或JSON格式）
2. 如果业务需要显示最新的证书信息，可以使用 `MAX(cert.start_time)` 配合子查询
3. 修改后需要重新测试所有相关接口

## 修改文件清单

- [ ] `src/main/resources/mapper/EmployeeMapper.xml` - 修改 `getEmployeeCertDetailsByDeptLevel` 方法




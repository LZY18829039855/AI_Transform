# 问题分析：任职数据缺失原因

## 问题描述

在全员状态下，相同职位类的认证数据与任职数据的人数总数不一致，**任职数据感觉有缺失**（比认证数据少）。

## 关键差异分析

### 1. 认证数据查询（getEmployeeCertDetailsByDeptLevel）

**JOIN 逻辑**：
- 使用简单的 JOIN 条件
- `queryType=1`：INNER JOIN，只返回有证书的员工
- `queryType=2`：LEFT JOIN，返回所有员工（即使没有证书）

**特点**：
- JOIN 条件简单直接
- 不会因为复杂的子查询逻辑导致数据丢失

### 2. 任职数据查询（getEmployeeQualifiedDetailsByDeptLevel）

**JOIN 逻辑**：
- 使用复杂的 JOIN 条件，包含子查询
- 子查询用于找到每个员工最高级别的AI任职记录

**关键问题点**：

#### 问题1：子查询条件过于严格

```sql
INNER JOIN t_qualifications q ON (
    e.employee_number = q.employee_number
    AND q.employee_number IS NOT NULL
    AND q.employee_number != ''
    AND q.direction_cn_name IN (
        '数据科学与AI工程（ICT）',
        'AI算法及应用（ICT）',
        'AI软件工程与工具（ICT）',
        'AI系统测试（ICT）'
    )
    AND q.competence_from IS NOT NULL
    AND q.competence_to IS NOT NULL
    AND CURDATE() BETWEEN q.competence_from AND q.competence_to
    AND q.competence_from = (
        -- 子查询：找到每个员工最高级别的AI任职记录的competence_from
        SELECT q2.competence_from
        FROM t_qualifications q2
        WHERE q2.employee_number = e.employee_number
        AND q2.employee_number IS NOT NULL
        AND q2.employee_number != ''
        AND q2.direction_cn_name IN (...)
        AND q2.competence_from IS NOT NULL
        AND q2.competence_to IS NOT NULL
        AND CURDATE() BETWEEN q2.competence_from AND q2.competence_to
        ORDER BY ... LIMIT 1
    )
)
```

**潜在问题**：
1. **子查询可能返回 NULL**：如果子查询没有找到匹配的记录，`q.competence_from = NULL` 永远不会为真
2. **日期范围限制**：`CURDATE() BETWEEN q.competence_from AND q.competence_to` 要求任职记录必须在当前日期范围内有效
3. **方向限制**：只查询特定的4个方向，如果员工有其他方向的任职记录，会被忽略

#### 问题2：与认证数据查询的逻辑不一致

**认证数据查询**：
- 查询所有有证书的员工（不考虑证书的有效期）
- 证书记录只要 `status = 1 OR approved_status = 1` 即可

**任职数据查询**：
- 查询有任职记录且**当前有效**的员工
- 要求 `CURDATE() BETWEEN q.competence_from AND q.competence_to`
- 如果员工的任职记录已过期，会被过滤掉

## 可能的原因

### 原因1：任职记录已过期

如果员工的任职记录不在当前日期范围内（`competence_from` 到 `competence_to`），会被过滤掉。

**示例**：
- 员工A在2024年1月1日到2024年12月31日有任职记录
- 当前日期是2025年1月1日
- 结果：员工A的任职记录已过期，不会被查询到

### 原因2：子查询逻辑问题

子查询使用 `ORDER BY ... LIMIT 1` 来找到最高级别的任职记录，但如果：
- 子查询返回 NULL
- 或者子查询返回的 `competence_from` 与主查询中的 `competence_from` 不匹配

会导致 JOIN 失败，员工被过滤掉。

### 原因3：方向限制

只查询4个特定方向的任职记录，如果员工有其他方向的任职记录，会被忽略。

## 解决方案建议

### 方案1：放宽日期范围限制（推荐）

如果业务允许，可以考虑查询所有任职记录（不限制有效期），或者查询最近N年内的任职记录。

### 方案2：优化子查询逻辑

使用窗口函数或更可靠的子查询逻辑，确保不会因为子查询返回 NULL 而导致数据丢失。

### 方案3：使用 LEFT JOIN + 条件判断

将 INNER JOIN 改为 LEFT JOIN，然后在 WHERE 子句中进行条件判断，这样可以保留所有员工记录。

### 方案4：与认证数据查询逻辑对齐

如果认证数据查询是正确的，可以考虑让任职数据查询也采用类似的简单逻辑，不进行复杂的子查询。

## 需要确认的问题

1. **业务需求**：任职数据是否应该只查询当前有效的任职记录？
2. **数据范围**：是否应该查询所有任职记录（包括已过期的）？
3. **方向限制**：是否应该查询所有方向的任职记录，还是只查询特定的4个方向？

## 下一步行动

1. 检查数据库中是否有大量已过期的任职记录
2. 对比认证数据和任职数据的员工工号列表，找出缺失的员工
3. 分析缺失员工的任职记录状态（是否过期、方向是否匹配等）
4. 根据业务需求确定是否需要修改查询逻辑



